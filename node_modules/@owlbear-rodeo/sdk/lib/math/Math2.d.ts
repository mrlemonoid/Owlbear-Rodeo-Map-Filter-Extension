import { Vector2 } from "../types/Vector2";
import { BoundingBox } from "../types";
/**
 * Math class for Vector2's
 * @example Add two Vector2's
 * ```ts
 * const a: Vector2 = { x: 100, y: 100 };
 * const b: Vector2 = { x: 50, y: 50 };
 * const c = Math2.add(a, b);
 * ```
 */
export declare class Math2 {
    /**
     * @summary magnitude is used here to not conflict with native length property
     * @returns The squared length of vector `p`
     */
    static magnitudeSquared(p: Vector2): number;
    /**
     * @summary magnitude is used here to not conflict with native length property
     * @returns The length of vector `p`
     */
    static magnitude(p: Vector2): number;
    /**
     * @returns `p` normalized, if length of `p` is 0 `{x: 0, y: 0}` is returned
     */
    static normalize(p: Vector2): Vector2;
    /**
     * @returns The dot product between `a` and `b`
     */
    static dot(a: Vector2, b: Vector2): number;
    /**
     * @returns `a` minus `b`
     */
    static subtract(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * @returns `a` plus `b`
     */
    static add(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * @returns `a` multiplied by `b`
     */
    static multiply(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * @returns `a` divided by `b`
     */
    static divide(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * Rotates a point around a given origin by an angle in degrees
     * @param point Point to rotate
     * @param origin Origin of the rotation
     * @param angle Angle of rotation in degrees
     * @returns Rotated point
     */
    static rotate(point: Vector2, origin: Vector2, angle: number): Vector2;
    /**
     * @returns The min of `a` and `b`
     */
    static min(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * @returns The component wise minimum of `a`
     */
    static componentMin(a: Vector2): number;
    /**
     * @returns The max of `a` and `b`
     */
    static max(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * @returns The component wise maximum of `a`
     */
    static componentMax(a: Vector2): number;
    /**
     * Rounds `p` to the nearest value of `to`
     */
    static roundTo(p: Vector2, to: Vector2): Vector2;
    /**
     * Floors `p` to the nearest value of `to`
     */
    static floorTo(p: Vector2, to: Vector2): Vector2;
    /**
     * @returns The component wise sign of `a`
     */
    static sign(a: Vector2): Vector2;
    /**
     * @returns The component wise absolute of `a`
     */
    static abs(a: Vector2): Vector2;
    /**
     * @returns `a` to the power of `b`
     */
    static pow(a: Vector2, b: Vector2 | number): Vector2;
    /**
     * Clamps `a` between `min` and `max`
     */
    static clamp(a: Vector2, min: number, max: number): Vector2;
    /**
     * Calculates an axis-aligned bounding box around an array of point
     */
    static boundingBox(points: Vector2[]): BoundingBox;
    /**
     * Checks to see if a point is in a polygon using ray casting
     * See more at {@link https://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm}
     * and {@link https://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon/2922778}
     */
    static pointInPolygon(p: Vector2, points: Vector2[]): boolean;
    /**
     * @returns True if the distance between `a` and `b` is under `threshold`
     */
    static compare(a: Vector2, b: Vector2, threshold: number): boolean;
    /**
     * @returns The distance between two vectors
     */
    static distance(a: Vector2, b: Vector2): number;
    /**
     * Linear interpolate between `a` and `b` by `alpha`
     */
    static lerp(a: Vector2, b: Vector2, alpha: number): Vector2;
    /**
     * @returns The centroid of the given points
     */
    static centroid(points: Vector2[]): Vector2;
}
